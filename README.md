# goit-algo-hw-04

Test results

Size: 100\
Insertion sort: 0.00011194200124009512 seconds\
Merge sort: 0.00010737699994933791 seconds\
Timsort (Python sorted): 8.005001291166991e-06 seconds

Size: 10000\
Insertion sort: 1.4042552360006084 seconds\
Merge sort: 0.013393744000495644 seconds\
Timsort (Python sorted): 0.0010226840004179394 seconds

Size: 50000\
Insertion sort: 36.78734290200009 seconds\
Merge sort: 0.07897546899948793 seconds\
Timsort (Python sorted): 0.007008458000200335 seconds


## Insertion Sort:
Працює досить добре для маленьких масивів, як-от 100 елементів, але зростає експоненційно з розміром даних, демонструючи дуже повільну продуктивність на масивах 10,000 та 50,000 елементів. Це підтверджує теоретичну складність O(n²).

## Merge Sort:
Дає стабільно хороші результати завдяки своїй складності O(n log n). Навіть на великих масивах із 50,000 елементів алгоритм працює досить швидко порівняно з сортуванням вставками.

## Timsort (Python sorted):
Найшвидший серед усіх алгоритмів на кожному з тестованих розмірів даних. Його продуктивність особливо помітна на великих масивах, де він у десятки разів швидший за сортування вставками і швидший за сортування злиттям. Це підтверджує ефективність Timsort для реальних завдань сортування, де він використовує комбінацію сортування злиттям та вставками.

## Загальний висновок:
Timsort значно випереджає інші алгоритми як на малих, так і на великих масивах, що робить його найкращим вибором для загальних завдань сортування в Python.